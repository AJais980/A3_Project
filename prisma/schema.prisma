generator client {
    provider = "prisma-client-js"
    output   = "../generated/prisma"
}

datasource db {
    provider = "postgresql"
}

model User {
    id                   String                @id @default(cuid())
    email                String                @unique
    username             String                @unique
    firebaseId           String                @unique
    name                 String?
    bio                  String?
    image                String?
    location             String?
    website              String?
    designation          Designation?
    isVerified           Boolean               @default(false)
    institution          String? // School, College, University, or Company name
    authMethod           AuthMethod            @default(GOOGLE) // GOOGLE, EMAIL_PASSWORD, EMAIL_OTP
    isOnline             Boolean               @default(false)
    lastSeen             DateTime?
    createdAt            DateTime              @default(now())
    updatedAt            DateTime              @updatedAt
    comments             Comment[]
    following            Follows[]             @relation("follower")
    followers            Follows[]             @relation("following")
    likes                Like[]
    notificationsCreated Notification[]        @relation("notificationCreator")
    notifications        Notification[]        @relation("userNotifications")
    posts                Post[]
    badges               UserBadge[]
    chatsAsUser1         Chat[]                @relation("User1Chats")
    chatsAsUser2         Chat[]                @relation("User2Chats")
    messages             Message[]
    reactions            Reaction[]
    verificationAttempts VerificationAttempt[]
}

model VerificationAttempt {
    id         String   @id @default(cuid())
    email      String
    otp        String
    attempts   Int      @default(0)
    maxRetries Int      @default(5)
    createdAt  DateTime @default(now())
    expiresAt  DateTime
    user       User?    @relation(fields: [userId], references: [id], onDelete: Cascade)
    userId     String?
    verified   Boolean  @default(false)

    @@index([email, expiresAt])
    @@index([userId])
}

model Post {
    id            String         @id @default(cuid())
    authorId      String
    content       String?
    fileType      String?
    createdAt     DateTime       @default(now())
    updatedAt     DateTime       @updatedAt
    fileName      String?
    fileExtension String?
    fileUrl       String?
    comments      Comment[]
    likes         Like[]
    notifications Notification[]
    author        User           @relation(fields: [authorId], references: [id], onDelete: Cascade)
}

model Comment {
    id            String         @id @default(cuid())
    content       String
    authorId      String
    postId        String
    parentId      String? // For nested replies
    rating        Int?
    createdAt     DateTime       @default(now())
    author        User           @relation(fields: [authorId], references: [id], onDelete: Cascade)
    post          Post           @relation(fields: [postId], references: [id], onDelete: Cascade)
    parent        Comment?       @relation("CommentReplies", fields: [parentId], references: [id], onDelete: Cascade)
    replies       Comment[]      @relation("CommentReplies")
    notifications Notification[]

    @@index([authorId, postId])
    @@index([parentId])
}

model Like {
    id        String   @id @default(cuid())
    postId    String
    userId    String
    createdAt DateTime @default(now())
    post      Post     @relation(fields: [postId], references: [id], onDelete: Cascade)
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([userId, postId])
    @@index([userId, postId])
}

model Follows {
    followerId  String
    followingId String
    createdAt   DateTime @default(now())
    follower    User     @relation("follower", fields: [followerId], references: [id], onDelete: Cascade)
    following   User     @relation("following", fields: [followingId], references: [id], onDelete: Cascade)

    @@id([followerId, followingId])
    @@index([followerId, followingId])
}

model UserBadge {
    id        String    @id @default(cuid())
    userId    String
    badgeType BadgeType
    earnedAt  DateTime  @default(now())
    user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([userId, badgeType])
    @@index([userId])
}

model Notification {
    id        String           @id @default(cuid())
    userId    String
    creatorId String
    type      NotificationType
    read      Boolean          @default(false)
    postId    String?
    commentId String?
    createdAt DateTime         @default(now())
    comment   Comment?         @relation(fields: [commentId], references: [id], onDelete: Cascade)
    creator   User             @relation("notificationCreator", fields: [creatorId], references: [id], onDelete: Cascade)
    post      Post?            @relation(fields: [postId], references: [id], onDelete: Cascade)
    user      User             @relation("userNotifications", fields: [userId], references: [id], onDelete: Cascade)

    @@index([userId, createdAt])
}

enum NotificationType {
    LIKE
    COMMENT
    FOLLOW
}

enum Designation {
    STUDENT
    TEACHER
    WORKING_PROFESSIONAL
}

enum AuthMethod {
    GOOGLE
    EMAIL_PASSWORD
    EMAIL_OTP
}

enum BadgeType {
    RISING_HELPER
    HELPFUL_MIND
    TRUSTED_ADVISOR
    STAR_MENTOR
    LEGENDARY_GUIDE
}

model Chat {
    id               String    @id @default(cuid())
    user1Id          String
    user2Id          String
    user1UnreadCount Int       @default(0)
    user2UnreadCount Int       @default(0)
    createdAt        DateTime  @default(now())
    updatedAt        DateTime  @updatedAt
    user1            User      @relation("User1Chats", fields: [user1Id], references: [id], onDelete: Cascade)
    user2            User      @relation("User2Chats", fields: [user2Id], references: [id], onDelete: Cascade)
    messages         Message[]

    @@unique([user1Id, user2Id])
    @@index([user1Id])
    @@index([user2Id])
}

model Message {
    id              String        @id @default(cuid())
    chatId          String
    senderId        String
    content         String
    createdAt       DateTime      @default(now())
    updatedAt       DateTime      @updatedAt
    isDeleted       Boolean       @default(false)
    deletedForUsers String[]      @default([])
    replyToId       String?
    status          MessageStatus @default(SENT)
    deliveredAt     DateTime?
    readAt          DateTime?
    chat            Chat          @relation(fields: [chatId], references: [id], onDelete: Cascade)
    sender          User          @relation(fields: [senderId], references: [id], onDelete: Cascade)
    replyTo         Message?      @relation("MessageReplies", fields: [replyToId], references: [id])
    replies         Message[]     @relation("MessageReplies")
    reactions       Reaction[]

    @@index([chatId, createdAt])
}

enum MessageStatus {
    SENT
    DELIVERED
    READ
}

model Reaction {
    id        String   @id @default(cuid())
    messageId String
    userId    String
    emoji     String
    createdAt DateTime @default(now())
    message   Message  @relation(fields: [messageId], references: [id], onDelete: Cascade)
    user      User     @relation(fields: [userId], references: [id], onDelete: Cascade)

    @@unique([messageId, userId])
    @@index([messageId])
}
